객체:클래스 틀로 짜서 힙에 저장. 이 번지를 가리키는 변수가 참조타입 변수

변수: JVM stack의 프레임 안의 스택 영역 쌓인다

메소드 영역: 클래스 코드들이 저장되는 곳. 클래스 별로 분류해서 저장한다.
각 클래스는 정적 필드/상수, 메소드 코드, 생성자 코드

메모리 사용영역 Runtime Data Area: 메소드 영역, 힙 영역, 스택 영역

String str = new String("Janna");
String str = "Janna"
// 같은 번지를 가리키냐 아니냐의 차이.

배열 변수 선언

int[] intArray = new int[30]; //0, null, false로 초기화된다
int[] intArray = {1,2,3};

초기값 원하는대로 채우기:

Arrays.fill(intArray,1);
Arrays.fill(intArray,1,30,1);



public static void main(String[] args)

args: 메인 메소드 호출할 때 실행되는 것
(클래스를 실행할 때 실행 매개값으로 문자열을 줄 수가 있다)

Config -> argument에서 수정가능


2차원 배열:
int[][] scores = new int[2][3];

for(int[] row: scores)
{
    Arrays.fill(row,1);
}




참조타입배열:
String[] strArray = new String[3];
strArray[0]= "";

System.arraycopy(origin, idx, obj, dest idx, len)



class:

필드: 클래스 안 다른 중괄호 외부에 선언하기

기본 생성자: 생성자 선어 ㄴ생략할 경우 바이트 코드 자동 추가.

매개변수, 필드 이름 동알하게 짓고, 값 넣을때 this.필드변수이름= 으로 넣기



객체: 속성(field, data), 필드(method) 로 구성.
자바가 객체지향 프로그래밍인 이유

현실 세계의 객체를 소프트웨어의 객체로 표현할 수 있도록 잘 만들어져 있기 때문

객체 지향 프로그래밍? 객체를 이용해 프로그램을 개발하는 방법


생성자 오버로딩. 

클래스 두 용도: 라이브러리, 실행 클래스(main() 메소드 제공 역할. 실행의 목적)


this() 코드:

하는 일이 중복될때.

Car(String a){
    String
    String
    int

    위에 다 지우고

    this(a,b,c) 로 바꾸기 된다. 안 지우면 안된다.? 생성자 첫줄에서만 허용.

}

Car(Stinga, String b){
    this(a,b,250);

}

Car(String a, String b, int c){

}


메소드 오버로딩: 리턴값 달라도 같아도된다




정적멤버 필드, 메소드 선언하는법: 앞에 static 붙이기
호출하는 법: (클래스이름).(호출할필드나 메소드)(메소드면 매개변수)

인스턴스 필드와 다른점: 인스턴스는 클래스 이름이 아니라 객체이름으로 부른다.


정적 멤버: 어떤 클래스 안의 필드나 메소드가 어떤 객체든 같을때, 이 필드나 메소드를 객체명.(필드or메소드)로 안부르고 클래스명.(필드or메소드)로 부를 수 있게
앞에 static 붙이는 것.
즉, 객체를 만들 수 있는 틀인 class 안에 필드나 메소드를 넣고는 싶은데, 얘네가 객체마다 달라질 필요가 없는 애라면 static으로 선언한다. 




싱글톤: 해당 클래스의 속성을 가진 객체 딱 하나만 만들고 싶을때. = 어떤 한 경우에만 이용할 고유 클래스틑 만들고 싶을때?
1. 그 하나의 객체는 싱글톤 용 클래스 안에 앞에 private 붙여서 만들어놓아야한다. -> "private static 싱글톤클래스 싱글객체이름 = new 싱글톤클래스(); "
2. "private 싱글톤클래스명() {}" 선언해서 외부에서 객체 생성 못하게 한다. 
3. 이 싱글톤객체를 불러올 수 있는 static 함수도 선언한다.
static 싱글톤클래스명 얘불러오기 // static으로 선언해야 싱글톤클래스명으로 접근할 수 있다. 외부에서 객체 만들 수 없는 싱글톤 클래스 이므로 불러오려면 static 써야한다.
{
    return 싱글객체이름
}



1. final: 한번 정의하면 고정된다.
종류 두개:
    instance final field: 필드에서 선언, 생성자에서 정의 가능
    static final field: 상수. 선언과 동시에 정의해야함.

37강:
패키지는 클래스를 유일하게 만들어주는 식별자 역할을 한다.
다른 패키지 class 가져와서 써야하는 경우 default가 아닌 public 이어야 하고
import 하위패키지 전부다 해줘야 한다.
Q) 다른패키지에 자식 객체 생성하면 부모의 protected 뚫릴까?

객체의 결성 유지하기 위해 getter, setter method 선언해준다.


40강:
상속이란? 이미 있는 클래스를 재사용한다
왜하는지? 중복되는 코드를 줄이기 위해. 부모 클래스 써야하는데 수정이 막혀있을때
상속 선언법: B extends A{}

상속한다고 다 가져오는 게 아니다: private 안됨, 다른 패키지면 default 안됨. protected는 될까? 돼야하는 거 아닌가

자식객체의 생성: 자식 호출 먼저되지만 자식 생성자 속 super()에 의해 부모생성자가 먼저 호출된다.

부모 생성자가 매개변수 선언 돼 있을때 super 신경 써줘야 한다.


41강: method overriding

정의방법: 메소드 이름 같게.
접근 제한 더 강하게 재정의 할 수 없음. 

Q) 똑같이 가져오라는 건가? 더 늘리는 건되나? ㅇㅇ 된다: 만들어진 자식 클래스 다른 패키지에서 쓸 수 있도록
새로운 예외 throws 할 수 없다: 이 부분 아직 안배움.

메소드 재정의해도 super.메소드이름(); 선언하면 부모 메소드 불러올 수 있다

default로 클래스 정의하면 같은 패키지 내에서는 상속할 수 있었다.
그 상속도 못하게 하려면 final 붙인다.

final method? 오버라이딩 못하게 막는다.

* 부모 메소드를 오버라이딩해서 새로 작성한 자식클래드의 메소드를 final로 지정할 수는 있다.


42강: 상속- 타입변환과 다양성
자동 타입변환(Promotion): 조상 클래스 타입으로 객체 만들때 자식객체 번지를 가져오면 일어난다.
B b = new B();
A a = b;

부모클래스에 선언된 멤버 + 자식에서 재정의됐다면 자식의 '메소드' 
*** 필드에서 부모 필드 재정의?해도 안가져온다!!

*메소드 만들때 함수처럼 클래스 안적고 친다. 생성자도 마찬가지.


43강: 필드의 다형성, 매개변수의 다형성

필드의 다형성:
클래스에 다른 부모 클래스 객체 만든다.

실제로 클래스 객체를 만들었을때,
만들어진 다른 부코 클래스 객체 안에 자식 객체 넣을 수 있다.

그럼 자식 객체가 메소드 재정의 했을때 재정의된 메소드가 실행된다.
*부모꺼만 쓸 수 있는데 부모꺼의 재정의된 메소드는 재저으이된 메소드가 실행된다?

* 넣으려면 반드시 객체 만들어서 넣어줘야함


매개변수의 다형성:
매개변수 받는 타입이 부모 클래스일때, 자식 타입 객체 만들어서 넣어 줄 수 있다.
효과는 위와 마찬가지.


44강: 강제타입변환
부모 클래스 private 멤버는 상속 대상에서 제외한다.
default 필드를 메인함수에서 바로 호출할 수 있는 이유? main 함수의 클래스가 같은 패키지에 소속된 클래스 이기 때문.

강제타입변환 조건: 자식타입이 부모타입으로 자동 타입 변환 된 이후 되돌릴때만.
A a = new B();
B b = (B) a;

객체명 instance of 클래스명: 강제타입변환 할 수 있는 객체인지 확인해준다.

45강: 추상 클래스, 추상 메소드
추상 클래스: 아래 자식 클래스가 상속받을 목적으로만 만드는거라 직접 객체를 생성할 수는 없다.
필드, 생성자, 메소드 가질 수 있다. 생성자: 자식 생성자에서 super의 형태로 호출되므로 반드시 추상클래스는 생성자가 있어야한다.

추성 메소드: {} 이 없다. 실체마다 공통된 특성을 갖고있는데 내용을 실체에서 결정해야할때.
강력한 기능: 하위클래스는 반드시 추상메소드를 재정의해서 실행내용을 채워야한다.


46강: 인터페이스
개발코드와 인터페이스를 통해 객체를 이용할 수 있게 만드는 것.
개발코드가 인터페이스 사용하는 코드는 바꾸지 않고 객체만 교환하면 다른 기능으로 대체할 수 있다.

선언:
publid interface 인터페이스이름{
    public int MAX=10l
    void mymethod(...); // {}없다.
    //default로 만들면 재정의가능한 실행내용 적을 수 있다.
}

인터페이스가 사용하는 객체 만들기: 구현 클래스 먼저 선언해야한다.
public class 클래스이름 implements 인터페이스이름{
    추상메소드의 실제메소드 선언
}

    1. 디폴드 메서드: 같은 패키지 내에 소속된 클래스에서만 사용. 실행내용까지 작성 가능하다, 재정의할 수 있다.
    2. 정적메소드: 객체없이 인터페이스만으로도 호출 가능하다.
    3. 익명구현 객체:
    인터페이스 변수 = new 인터페이스(){
        //인터페이스에서 선언된 추상메소드의 실제 메소드 구현
    }

47강: 타입변환과 다양성
자동 타입변환: 인터페이스로 클래스의 객체 받을때 인터페이스에서 선언된 애만 쓸 수 있도록 자동 타입변환된다.
인터페이스 멤버 외 구현클래스의 순수 멤버들을 사용하고 싶으면 강제타입변환 시킨다.

Vehicle vehicle= new Taxi();
Taxi taxi= (Taxi)vehicle;
타입 변환하려면 새로운 변수 선언해줘야한다!

인터페이스는 여러개 상속할 수 있는데,
하위 인터페이스로 받은 객체의 구현클래스에는 상속된 인터페이스 메소드 다 구현돼있어야한다.

public class ClassName implements A{}
의 ClassName의 객체는 인타페이스 A뿐만아니라 A의 상위 인터페이스로도 받을 수 있다.


48강: 중첩클래스와 인터페이스
중첩클래스: 인트턴스, 정적 멤버 클래스 두 개로 나뉜다.
    인스턴스 멤버 클래스는 안에 정적 필드, 메소드 선언할 수 없다. 왜? 반드시 상위 클래스 객체를 선언해야 쓸 수 있기 때문.
A a = new A();
A.B b = a.new B();

    정적 멤버 클래스는 정적 멤버, 인스턴스 멤버 다 선언할 수 있다.

1. 정적 멤버 클래스의 인스턴스 이용하기
A.C c = new A.C(); // A 객체 없이 바로 선언가능하다.
객체 c로 정적 멤버 클래스 C의 인스턴스 멤버 불러올 수 있다.

2. 정적 멤버 클래스로 정적 멤버 이용하기
A.C.~ 바로 쓸 수 있다.


49강: 중첩클래스의 접근제한

1. 클래스 안에서 중첩 클래스 객체 정적으로 만드려면 중첩클래스가 정접 타입으로 만들어졌어야한다.
    Q) 정적 객체를 만든단 게 무슨소리?
2. 중첩 클래스 안에서 바깥 멤버를 소환하거나 건들이려면 걔네가 정적타입이어야 한다.

3. 메소드 안의 중첩클래스: 로컬 클래스.
    로컬클래스에서 메소드의 매개변수나 필드 사용하려면 걔네가 정적타입이어야한다, 자바8부턴 알아서 특성 부여된다.

4. 중첩클래스에선, 바깥 클래스 멤버 이름과 똑같은 애들 만들 수 있는데 바깥 클래스 멤버 불러오려면?
 -> 바깥클래스.this 해준다.

 