가장 긴 증가수열:
dp[i] :  L[i] 이 last인 경우
10<30 이고 20<30 이므로
10 30, 10 20 30  등 모두 가능하다. 이중에 최대만 가져가려면 
dp[i] = max(dp[i], current step)

for i in range(len(L)):
    for j in range(i): # 현제 커서 이전의 애들 중에 붙임 당할 수 있는 거 모두 검사하기.

ㅡㅡㅡ
1로 만들기:
for 문 돌 때 조건마다 바꿔야하는 요소가 있을때 if 들 써야할지 elif 로 써도 될 지 잘 생각하기.

ㅡㅡㅡ
            for k in range(j):
                if j-k==board[i][k]:
                    dp[i][j]+=dp[i][k]

상황마다 위에를 여러번 써야해서 복사해야 한다면:
	하나씩 복사해서 인수 바꾸기
	될 수 있으면 x좌표별 인덱스, y좌표별 인덱스 통일하기
	하나씩 안바꾸는 실수 한다. 

ㅡㅡㅡ
퇴사:
쉬는 날 없이 일정이 붙어있지 않는 스케줄이 더 많은 금액을 받을 수도 있다.
연결할 때 <= 이용하기
i+cn[i][0] <= N 이 아니라
i+cn[i][0] <+ N+1 이다.

ㅡㅡㅡ
동전 만들기
존재하는 동전으로 첫 포문 돌리기.
경우의 수 세는법:
지금 동전을 "1번 이상 쓰고" , 지금 동전과 예전 동전들"만"을 이용해서 i원을 만들 수 있는 경우의 수를 더한다.

ㅡㅡㅡ

