"""
선생님 안녕하세요!! ㅎㅎ 문제 풀이 과외 승낙해주셔서 감사합니다.

이 코드는 RE, WA 뜬 오답 코드입니다.

세로가 한줄 짜리였을 경우엔 min과 max 오류없이 잘 출력이 되어 42점 받은 코드에요.



우선 제가 짠 코드가 지도의 x,y 좌표체크를 하나하나 이중포문으로 돌려서 하는 식이라,
애초에 거의 처음부터 다시 짜야하는 건 이해 했습니다. 

나머지 세로가 두 줄 이상일 때, min 은 RE (아마도 인덱스 초과문제), max는 WA(왜 틀렸는지는 반례를 가지고 있어서 알고있음)
라고 뜹니다. 

그런데 min 부분은 max와 같이 반례 없이 논리적으로는 완벽하게 짰다고 생각하거든요

인덱스 초과도 안나게 하려고 조건 열심히 넣어가면서 꼼꼼히 봤습니다.

그런데도 RE라고 뜨길래, 이중포문으로 인한 TLE 가 나기 전에 애초에 인덱싱 에서 코드 오류가 있다는 뜻 같습니다.

이걸 우선 확인해서 어디가 틀렸는지 알려 주실 수 있을까요?



그리고 

제 코드의 시간복잡도를 구하고 싶은데요, 

이중포문은 n^2 으로 계산한 다고 쳐도 맨 아래 땅 세는 이중 포문 안에 무한루프가 있어서요. 

이럴 땐 시간복잡도를 어떻게 확인하는지도 알려주시길 부탁드립니다.

"""

import copy

a, b = [int(i) for i in input().split()]
maaaap = input()
L = []

for i in range(a): # a가 세로
    L.append([0]*b)


   
C = copy.deepcopy(L)

for i in range(a): # L안에 지도의 내용물을 넣어주고
    mapp = input()
    for j in range(b):
        if (mapp[j] == 'L'):
            L[i][j] = 1 # 1을 땅으로
        elif (mapp[j] == 'S'):
            L[i][j] = 2 # 2 바다
        else:
            L[i][j] = -1 # 물음표







answer=0
if(maaaap=='min'):
   
    #print(L)
    for i in range(a): # 현재 좌표가 물음표라면, 주변에 땅이 하나라도 있으면 주변 물음 표 다 땅으로 채우기
        for j in range(b):
            if L[i][j]==-1:
                # L[0][0] ~ L[a-1][b-1]
                # b가 j고 가로
                
                if j+1<=b-1 and L[i][j+1]==1:
                    L[i][j]=1
                    
                elif 0<= j-1 and L[i][j-1]==1:
                    L[i][j]=1
                    
                elif 0<=i-1 and L[i-1][j]==1:
                    L[i][j]=1
                    
                elif i+1<=a-1 and L[i+1][j]==1 :
                    L[i][j]=1
                    
                else: 
                    L[i][j]=2
                    print(i,j,"바다칠했다")
                   
 
               
    #print(L)            
               
else: #max
    for i in range(a): #현재 좌표가 땅일때, 오른쪽이나 아래가 물음표면 바다로 채우기
        for j in range(b):
            if L[i][j] == 1: # L[0][0] ~ L[a-1][b-1] i+1<=a-1   i
                if i+1<=a-1 and L[i+1][j]!=1:
                    L[i+1][j] = 2
                if j+1<=b-1 and L[i][j+1]!=1: # j+1<=b-1
                    L[i][j+1] = 2 #오른쪽이랑 아래 바다로 채우기
                   
               
    for i in range(a): # 나머지 빈칸을 땅물땅물로 바꾸는 전략인데, 이렇게 하면 반례그림에서 걸린다.
        for j in range(b):
            if L[i][j]==-1:
                L[i][j]=1 

                if i+1<=a-1 and L[i+1][j]==-1:
                    L[i+1][j]=2
                if j+1<=b-1 and L[i][j+1]==-1:
                    L[i][j+1]=2 
                   



z=0    

"""
땅 세는 법: 
    1. 체크가 안된 땅을 발견하면 땅을 세고 체크 표시를 한다. 
    2. 방금 센 땅 주변에 땅이있으면 그 땅들에도 체크표시한다.
    3. 그 땅들의 두변에도 땅이 있으면 체크표시하는 과정을 반복한다.
 
 
되는 지 확인:
    
입력:
10 9
min
SSLS??S?S
??LSS????
??L??????
LLL??????
SSLSSSSSS
LLLLLLLLL
S?S?S?S?S
S?S?S?S?S
S?S?S?S?S
S?S?S?S?S


출력:
1


"""
for i in range(a): 
        for j in range(b):
            if L[i][j] == 1: # 4 5 L[3][4]
                if C[i][j]!=3: # 체크되지 않은 땅을 체크했을떄 꼬리에 꼬리를 물고 체크해주자
                    z += 1
                    C[i][j] = 3
                    #print("여기가 새 땅이라서 땅 셌다.",i,j,C[i][j])

                
                if C[i][j]==3:
                    #print(i,j)
                    if i+1<=a-1: # 아래가 존
                        if L[i+1][j] == 1 and C[i+1][j]!=3: #아래가땅이었다
                            C[i+1][j] = 3
                            y=0 # 아래 i+1<=a-1
                            
                            while (1):
                                if i+1+y <=a-1 and L[i+1+y][j]==1:
                                    
                                    C[i+1+y][j] = 3 # L 좌우대칭으로 이어진 땅 찾자
                                    #print("L자 찾기",i+1+y,j)
                                    
                                else:
                                    break
                                x=0 
                                while (1):
                                    if j-x >=0 and L[i+1+y][j-x]==1:
                                        
                                        C[i+1+y][j-x]=3
                                        #print("L자 찾기",i+1+y,j-x)
                                        x+=1
                                    else:
                                        break
                                y+=1
                           
                    if j+1<=b-1:
                        if L[i][j+1] == 1:
                            C[i][j+1] = 3

                            
                           
#print(C)                
                   

                            
print(z)


