객체:클래스 틀로 짜서 힙에 저장. 이 번지를 가리키는 변수가 참조타입 변수

변수: JVM stack의 프레임 안의 스택 영역 쌓인다

메소드 영역: 클래스 코드들이 저장되는 곳. 클래스 별로 분류해서 저장한다.
각 클래스는 정적 필드/상수, 메소드 코드, 생성자 코드

메모리 사용영역 Runtime Data Area: 메소드 영역, 힙 영역, 스택 영역

String str = new String("Janna");
String str = "Janna"
// 같은 번지를 가리키냐 아니냐의 차이.

배열 변수 선언

int[] intArray = new int[30]; //0, null, false로 초기화된다
int[] intArray = {1,2,3};

초기값 원하는대로 채우기:

Arrays.fill(intArray,1);
Arrays.fill(intArray,1,30,1);



public static void main(String[] args)

args: 메인 메소드 호출할 때 실행되는 것
(클래스를 실행할 때 실행 매개값으로 문자열을 줄 수가 있다)

Config -> argument에서 수정가능


2차원 배열:
int[][] scores = new int[2][3];

for(int[] row: scores)
{
    Arrays.fill(row,1);
}




참조타입배열:
String[] strArray = new String[3];
strArray[0]= "";

System.arraycopy(origin, idx, obj, dest idx, len)



class:

필드: 클래스 안 다른 중괄호 외부에 선언하기

기본 생성자: 생성자 선어 ㄴ생략할 경우 바이트 코드 자동 추가.

매개변수, 필드 이름 동알하게 짓고, 값 넣을때 this.필드변수이름= 으로 넣기



객체: 속성(field, data), 필드(method) 로 구성.
자바가 객체지향 프로그래밍인 이유

현실 세계의 객체를 소프트웨어의 객체로 표현할 수 있도록 잘 만들어져 있기 때문

객체 지향 프로그래밍? 객체를 이용해 프로그램을 개발하는 방법


생성자 오버로딩. 

클래스 두 용도: 라이브러리, 실행 클래스(main() 메소드 제공 역할. 실행의 목적)


this() 코드:

하는 일이 중복될때.

Car(String a){
    String
    String
    int

    위에 다 지우고

    this(a,b,c) 로 바꾸기 된다. 안 지우면 안된다.? 생성자 첫줄에서만 허용.

}

Car(Stinga, String b){
    this(a,b,250);

}

Car(String a, String b, int c){

}


메소드 오버로딩: 리턴값 달라도 같아도된다




정적멤버 필드, 메소드 선언하는법: 앞에 static 붙이기
호출하는 법: (클래스이름).(호출할필드나 메소드)(메소드면 매개변수)

인스턴스 필드와 다른점: 인스턴스는 클래스 이름이 아니라 객체이름으로 부른다.


정적 멤버: 어떤 클래스 안의 필드나 메소드가 어떤 객체든 같을때, 이 필드나 메소드를 객체명.(필드or메소드)로 안부르고 클래스명.(필드or메소드)로 부를 수 있게
앞에 static 붙이는 것.
즉, 객체를 만들 수 있는 틀인 class 안에 필드나 메소드를 넣고는 싶은데, 얘네가 객체마다 달라질 필요가 없는 애라면 static으로 선언한다. 




싱글톤: 해당 클래스의 속성을 가진 객체 딱 하나만 만들고 싶을때. = 어떤 한 경우에만 이용할 고유 클래스틑 만들고 싶을때?
1. 그 하나의 객체는 싱글톤 용 클래스 안에 앞에 private 붙여서 만들어놓아야한다. -> "private static 싱글톤클래스 싱글객체이름 = new 싱글톤클래스(); "
2. "private 싱글톤클래스명() {}" 선언해서 외부에서 객체 생성 못하게 한다. 
3. 이 싱글톤객체를 불러올 수 있는 static 함수도 선언한다.
static 싱글톤클래스명 얘불러오기 // static으로 선언해야 싱글톤클래스명으로 접근할 수 있다. 외부에서 객체 만들 수 없는 싱글톤 클래스 이므로 불러오려면 static 써야한다.
{
    return 싱글객체이름
}



1. final: 한번 정의하면 고정된다.
종류 두개:
    instance final field: 필드에서 선언, 생성자에서 정의 가능
    static final field: 상수. 선언과 동시에 정의해야함.

37강:
패키지는 클래스를 유일하게 만들어주는 식별자 역할을 한다.
다른 패키지 class 가져와서 써야하는 경우 default가 아닌 public 이어야 하고
import 하위패키지 전부다 해줘야 한다.
Q) 다른패키지에 자식 객체 생성하면 부모의 protected 뚫릴까?

객체의 결성 유지하기 위해 getter, setter method 선언해준다.


40강:
상속이란? 이미 있는 클래스를 재사용한다
왜하는지? 중복되는 코드를 줄이기 위해. 부모 클래스 써야하는데 수정이 막혀있을때
상속 선언법: B extends A{}

상속한다고 다 가져오는 게 아니다: private 안됨, 다른 패키지면 default 안됨. protected는 될까? 돼야하는 거 아닌가

자식객체의 생성: 자식 호출 먼저되지만 자식 생성자 속 super()에 의해 부모생성자가 먼저 호출된다.

부모 생성자가 매개변수 선언 돼 있을때 super 신경 써줘야 한다.


41강: method overriding

정의방법: 메소드 이름 같게.
접근 제한 더 강하게 재정의 할 수 없음. 

Q) 똑같이 가져오라는 건가? 더 늘리는 건되나? ㅇㅇ 된다: 만들어진 자식 클래스 다른 패키지에서 쓸 수 있도록
새로운 예외 throws 할 수 없다: 이 부분 아직 안배움.

메소드 재정의해도 super.메소드이름(); 선언하면 부모 메소드 불러올 수 있다

default로 클래스 정의하면 같은 패키지 내에서는 상속할 수 있었다.
그 상속도 못하게 하려면 final 붙인다.

final method? 오버라이딩 못하게 막는다.

* 부모 메소드를 오버라이딩해서 새로 작성한 자식클래드의 메소드를 final로 지정할 수는 있다.






